#!/bin/bash

# 作者：@纆泽@deepseek

show_notice() {
    echo ""
    echo "=================================================="
    echo "注意事项："
    echo "编译完成后请前往debox菜单中"切换dxvk"选项查看"
    echo "文件会以debox为开头命名"
    echo "=================================================="
    echo ""
}

# 获取当前DXVK最新版本
get_dxvk_latest_version() {
    echo "正在获取最新版本..."
    # 从GitHub API获取最新release版本
    latest_version=$(curl -s https://api.github.com/repos/doitsujin/dxvk/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    if [ -n "$latest_version" ]; then
        echo "$latest_version"
    else
        echo "获取失败"
    fi
}

# 检查文件是否已存在
check_file_exists() {
    local version=$1
    local clean_version=$(echo "$version" | sed 's/^v//')
    local filename="debox-dxvk-${clean_version}.tar.gz"
    local filepath="/data/data/com.termux/files/usr/glibc/opt/dxvk/${filename}"
    
    if [ -f "$filepath" ]; then
        echo -e "\033[1;33m⚠ 文件已存在: $filename\033[0m"
        read -p "是否继续？[y/N] " choice
        if [[ ! $choice =~ [yY] ]]; then
            echo "操作已取消"
            return 1
        fi
    fi
    return 0
}

# 重新打包DXVK文件
repack_dxvk() {
    local version_name=$1
    local clean_version=$(echo "$version_name" | sed 's/^v//')
    local temp_dir="/data/data/com.termux/files/usr/glibc/opt/dxvk/dxvk-${clean_version}"
    
    echo -e "\033[1;36m▶ 开始重新打包DXVK\033[0m"
    
    # 检查原始文件是否存在 - 尝试两种可能的文件名格式
    local original_file=""
    if [ -f "/data/data/com.termux/files/usr/glibc/opt/dxvk/dxvk-${version_name}.tar.gz" ]; then
        original_file="dxvk-${version_name}.tar.gz"
    elif [ -f "/data/data/com.termux/files/usr/glibc/opt/dxvk/dxvk-${clean_version}.tar.gz" ]; then
        original_file="dxvk-${clean_version}.tar.gz"
    else
        echo -e "\033[1;31m✗ 原始文件不存在，无法重新打包\033[0m"
        echo "查找的文件:"
        echo "  - dxvk-${version_name}.tar.gz"
        echo "  - dxvk-${clean_version}.tar.gz"
        return 1
    fi
    
    echo "找到原始文件: $original_file"
    
    # 解压原始文件
    cd /data/data/com.termux/files/usr/glibc/opt/dxvk
    tar -xzf "$original_file"
    
    # 进入解压后的目录
    cd "dxvk-${clean_version}"
    
    # 重命名文件夹
    if [ -d "x32" ]; then
        mv "x32" "syswow64"
        echo "✓ 已将 x32 重命名为 syswow64"
    fi
    
    if [ -d "x64" ]; then
        mv "x64" "system32"
        echo "✓ 已将 x64 重命名为 system32"
    fi
    
    # 返回上级目录
    cd ..
    
    # 重新打包 - 直接打包文件夹内容，不包含顶层目录
    echo "正在重新打包..."
    
    # 使用-C参数改变目录
    tar -czf "debox-dxvk-${clean_version}.tar.gz" -C "dxvk-${clean_version}" .
    
    # 检查打包是否成功
    if [ $? -eq 0 ]; then
        echo -e "\033[1;32m✓ 文件已重新打包为: debox-dxvk-${clean_version}.tar.gz\033[0m"
        
        # 验证打包内容
        echo "验证打包内容:"
        tar -tzf "debox-dxvk-${clean_version}.tar.gz" | head -10
        
        # 删除临时文件
        rm -rf "dxvk-${clean_version}" "$original_file"
        echo "✓ 已删除临时文件和原始下载文件"
        return 0
    else
        echo -e "\033[1;31m✗ 重新打包失败\033[0m"
        # 清理临时文件
        rm -rf "dxvk-${clean_version}"
        return 1
    fi
}

# 处理编译后的DXVK目录
process_built_dxvk() {
    local version_name=$1
    local clean_version=$(echo "$version_name" | sed 's/^v//')
    
    echo -e "\033[1;36m▶ 开始处理编译的DXVK\033[0m"
    
    # 检查编译输出的目录是否存在
    if [ ! -d "/data/data/com.termux/files/usr/glibc/opt/dxvk/dxvk-${version_name}" ]; then
        echo -e "\033[1;31m✗ 编译输出目录不存在\033[0m"
        return 1
    fi
    
    cd "/data/data/com.termux/files/usr/glibc/opt/dxvk/dxvk-${version_name}"
    
    # 重命名文件夹
    if [ -d "x32" ]; then
        mv "x32" "syswow64"
        echo "✓ 已将 x32 重命名为 syswow64"
    fi
    
    if [ -d "x64" ]; then
        mv "x64" "system32"
        echo "✓ 已将 x64 重命名为 system32"
    fi
    
    # 返回上级目录
    cd ..
    
    # 重新打包 - 直接打包文件夹内容，不包含顶层目录
    echo "正在重新打包..."
    
    # 使用-C参数改变目录
    tar -czf "debox-dxvk-${clean_version}.tar.gz" -C "dxvk-${version_name}" .
    
    # 检查打包是否成功
    if [ $? -eq 0 ]; then
        echo -e "\033[1;32m✓ 文件已重新打包为: debox-dxvk-${clean_version}.tar.gz\033[0m"
        
        # 验证打包内容
        echo "验证打包内容:"
        tar -tzf "debox-dxvk-${clean_version}.tar.gz" | head -10
        
        # 删除临时目录
        rm -rf "dxvk-${version_name}"
        echo "✓ 已删除编译生成的临时目录"
        return 0
    else
        echo -e "\033[1;31m✗ 重新打包失败\033[0m"
        return 1
    fi
}

main_menu() {
    clear
    echo "======================================"
    echo "       DXVK 编译/下载工具 v1.0"
    echo "======================================"
    echo "1. 编译最新版本"
    echo "2. 编译指定版本"
    echo "3. 下载DXVK"
    echo "0. 退出脚本"
    echo "======================================"
    
    # 显示当前DXVK最新版本区域
    echo ""
    echo "══════════════════════════════════════"
    echo "        DXVK 版本信息"
    echo "══════════════════════════════════════"
    echo "最新版本: $(get_dxvk_latest_version)"
    echo "══════════════════════════════════════"
    echo ""
    
    show_notice
}

download_menu() {
    clear
    echo "======================================"
    echo "          下载 DXVK"
    echo "======================================"
    echo "1. 下载最新版本"
    echo "2. 下载指定版本"
    echo "0. 返回主菜单"
    echo "======================================"
}

check_directory() {
    if [ -d ~/dxvk ]; then
        read -p "检测到存在的dxvk目录，是否删除？[y/N] " choice
        if [[ $choice =~ [yY] ]]; then
            rm -rf ~/dxvk || return 1
            echo "✓ 已删除存在的dxvk目录"
        else
            echo "操作已取消，请手动处理目录后重试"
            exit 1
        fi
    fi
}

run_build() {
    local version=$1
    
    # 创建输出目录
    mkdir -p /data/data/com.termux/files/usr/glibc/opt/dxvk
    
    if [ -z "$version" ]; then
        echo -e "\033[1;36m▶ 正在克隆最新DXVK源码\033[0m"
        git clone --recursive https://github.com/doitsujin/dxvk.git ~/dxvk || {
            echo "仓库克隆失败！请检查网络连接"
            exit 1
        }
        version_name="master"
    else
        echo -e "\033[1;36m▶ 正在克隆DXVK版本: $version\033[0m"
        git clone --recursive --branch "$version" https://github.com/doitsujin/dxvk.git ~/dxvk || {
            echo "指定版本下载失败！请检查版本号"
            exit 1
        }
        version_name="$version"
    fi

    # 检查文件是否已存在
    if ! check_file_exists "$version_name"; then
        rm -rf ~/dxvk
        return
    fi

    cd ~/dxvk || {
        echo "无法进入dxvk目录"
        exit 1
    }

    echo -e "\033[1;36m▶ 开始编译DXVK\033[0m"
    # 使用--no-package参数编译但不打包
    ./package-release.sh "$version_name" /data/data/com.termux/files/usr/glibc/opt/dxvk --no-package

    # 处理编译后的目录
    if process_built_dxvk "$version_name"; then
        echo -e "\n\033[1;32m✓ DXVK编译和重新打包完成！\033[0m"
        echo "文件位置: /data/data/com.termux/files/usr/glibc/opt/dxvk/debox-dxvk-$(echo "$version_name" | sed 's/^v//').tar.gz"
    else
        echo -e "\033[1;31m✗ DXVK编译或重新打包失败\033[0m"
    fi

    # 自动删除编译目录，不再询问
    echo -e "\033[1;36m▶ 清理编译目录\033[0m"
    rm -rf ~/dxvk
    echo "✓ 编译目录已删除"
}

run_download() {
    local version=$1
    
    # 创建输出目录
    mkdir -p /data/data/com.termux/files/usr/glibc/opt/dxvk
    
    if [ -z "$version" ]; then
        echo -e "\033[1;36m▶ 正在获取最新DXVK版本\033[0m"
        version_name=$(curl -s https://api.github.com/repos/doitsujin/dxvk/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
        if [ -z "$version_name" ]; then
            echo "获取最新版本失败！"
            exit 1
        fi
        echo "最新版本: $version_name"
    else
        version_name="$version"
    fi

    # 检查文件是否已存在
    if ! check_file_exists "$version_name"; then
        return
    fi

    # 处理版本号，移除可能的v前缀
    clean_version=$(echo "$version_name" | sed 's/^v//')
    
    echo -e "\033[1;36m▶ 正在下载DXVK $version_name\033[0m"
    
    # 下载DXVK发布包
    cd /data/data/com.termux/files/usr/glibc/opt/dxvk
    
    # 修复下载链接 - DXVK发布包的文件名格式是 dxvk-{version}.tar.gz (没有v前缀)
    download_url="https://github.com/doitsujin/dxvk/releases/download/${version_name}/dxvk-${clean_version}.tar.gz"
    
    echo "下载链接: $download_url"
    
    if wget "$download_url"; then
        echo -e "\033[1;32m✓ 下载完成，开始重新打包\033[0m"
        
        # 重新打包并重命名文件夹
        if repack_dxvk "$version_name"; then
            echo -e "\n\033[1;32m✓ DXVK下载和重新打包完成！\033[0m"
            echo "文件位置: /data/data/com.termux/files/usr/glibc/opt/dxvk/debox-dxvk-${clean_version}.tar.gz"
        else
            echo -e "\033[1;31m✗ DXVK重新打包失败\033[0m"
        fi
    else
        echo -e "\033[1;31m✗ 下载失败！请检查网络连接和版本号\033[0m"
        echo "提示: 可以尝试手动从以下链接下载:"
        echo "$download_url"
    fi
}

while true; do
    main_menu
    read -p "请输入选项：" choice
    case $choice in
        1) 
            check_directory
            run_build
            ;;
        2)
            check_directory
            echo "正在获取版本列表..."
            # 获取所有release标签，按版本号排序
            tags=$(git ls-remote --tags https://github.com/doitsujin/dxvk.git | \
                   awk -F/ '{print $3}' | grep -v '\^{}' | sort -Vr)
            tags="$tags 返回主菜单"
            PS3="请选择版本 (输入数字): "
            select tag in $tags; do
                if [ "$tag" == "返回主菜单" ]; then
                    echo "正在返回主菜单..."
                    sleep 1
                    break
                elif [ -n "$tag" ]; then
                    break
                else
                    echo "无效选择，请重新输入"
                fi
            done
            if [ "$tag" == "返回主菜单" ]; then
                continue
            fi
            run_build $tag
            ;;
        3)
            download_menu
            read -p "请输入选项：" download_choice
            case $download_choice in
                1)
                    run_download
                    ;;
                2)
                    echo "正在获取版本列表..."
                    # 获取所有release标签，按版本号排序
                    tags=$(curl -s https://api.github.com/repos/doitsujin/dxvk/releases | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' | sort -Vr)
                    tags="$tags 返回主菜单"
                    PS3="请选择版本 (输入数字): "
                    select tag in $tags; do
                        if [ "$tag" == "返回主菜单" ]; then
                            echo "正在返回主菜单..."
                            sleep 1
                            break
                        elif [ -n "$tag" ]; then
                            break
                        else
                            echo "无效选择，请重新输入"
                        fi
                    done
                    if [ "$tag" == "返回主菜单" ]; then
                        continue
                    fi
                    run_download $tag
                    ;;
                0) ;;
                *) echo "无效选择" ;;
            esac
            ;;
        0) 
            echo "脚本退出"
            exit 0
            ;;
        *) echo "无效选项" ;;
    esac
    read -p "按回车键继续..."
done